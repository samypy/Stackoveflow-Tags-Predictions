import os
import glob
import pandas as pd

# set directory path
directory_path = "/path/to/directory"

# check if the directory exists
if not os.path.isdir(directory_path):
    print("Directory does not exist.")
    exit()

# get list of excel files in all subdirectories
excel_files = glob.glob(os.path.join(directory_path, '**/*.xlsx'), recursive=True)

# check if there are any excel files in directory
if not excel_files:
    print("No excel files found in directory.")
    exit()

# read first excel file to get number of columns and headers
df = pd.read_excel(excel_files[0])
num_cols = len(df.columns)
headers = list(df.columns)

# loop through excel files and merge them
for i, excel_file in enumerate(excel_files):
    # read excel file
    df = pd.read_excel(excel_file)
    
    # check if number of columns matches
    if len(df.columns) != num_cols:
        print(f"Skipping {excel_file} because number of columns does not match.")
        continue
    
    # skip header rows for all files except the first one
    if i > 0:
        df = df.iloc[1:]
        df.columns = headers
    
    # merge dataframes
    if i == 0:
        merged_df = df
    else:
        merged_df = pd.concat([merged_df, df], axis=0)
        
# save merged dataframe to excel file
merged_df.to_excel(os.path.join(directory_path, "merged.xlsx"), index=False)
print("Merged file saved to directory.")



import tkinter as tk
from tkinter import filedialog
import fitz

class PDFProcessor:
    def __init__(self, master):
        self.master = master
        self.master.title("PDF Processor")
        self.master.geometry("500x300")
        
        # create log text widget
        self.log_text = tk.Text(self.master, height=10)
        self.log_text.pack(fill=tk.BOTH, expand=True)
        
        # create select pdf button
        self.pdf_button = tk.Button(self.master, text="Select PDF", command=self.select_pdf)
        self.pdf_button.pack(pady=10)
        
        # create select output folder button
        self.output_button = tk.Button(self.master, text="Select Output Folder", command=self.select_output)
        self.output_button.pack(pady=10)
        
        # create process button
        self.process_button = tk.Button(self.master, text="Process", command=self.process_pdf)
        self.process_button.pack(pady=10)
        
        # initialize variables
        self.pdf_file = None
        self.output_folder = None
        
    def select_pdf(self):
        # prompt user to select pdf file
        self.pdf_file = filedialog.askopenfilename(title="Select PDF File", filetypes=[("PDF Files", "*.pdf")])
        self.log(f"Selected PDF file: {self.pdf_file}")
        
    def select_output(self):
        # prompt user to select output folder
        self.output_folder = filedialog.askdirectory(title="Select Output Folder")
        self.log(f"Selected output folder: {self.output_folder}")
        
    def process_pdf(self):
        if not self.pdf_file:
            self.log("Please select a PDF file.")
            return
        if not self.output_folder:
            self.log("Please select an output folder.")
            return
        
        # open input pdf file
        pdf_document = fitz.open(self.pdf_file)
        num_pages = pdf_document.page_count
        self.log(f"Number of pages in PDF: {num_pages}")
        
        # generate images from pdf pages
        for page_num in range(num_pages):
            # get pdf page
            pdf_page = pdf_document[page_num]
            
            # generate image from pdf page
            pix = pdf_page.get_pixmap()
            
            # save image to output folder
            output_file = f"{self.output_folder}/page_{page_num+1}.png"
            pix.save(output_file)
            self.log(f"Page {page_num+1} saved to: {output_file}")
        
        # close pdf document
        pdf_document.close()
        
    def log(self, message):
        # add message to log text widget
        self.log_text.insert(tk.END, f"{message}\n")
        self.log_text.see(tk.END)
        
if __name__ == "__main__":
    # create main window
    root = tk.Tk()
    
    # create pdf processor UI
    pdf_processor = PDFProcessor(root)
    
    # run UI
    root.mainloop()


import fitz
import os
import PySimpleGUI as sg

def convert_pdf_to_images(pdf_path, output_folder, resolution):
    doc = fitz.open(pdf_path)
    name = os.path.splitext(os.path.basename(pdf_path))[0]
    images_folder = os.path.join(output_folder, name)
    os.makedirs(images_folder, exist_ok=True)
    for i in range(len(doc)):
        page = doc[i]
        rotate = int(0)
        zoom_x = float(resolution) / 100.0
        zoom_y = float(resolution) / 100.0
        trans = fitz.Matrix(zoom_x, zoom_y).preRotate(rotate)
        pm = page.getPixmap(matrix=trans, alpha=False)
        output_file = os.path.join(images_folder, f"{name}_page{i+1}.png")
        pm.writePNG(output_file)

sg.theme('DarkBlue')
layout = [[sg.Text('Select PDF File:'), sg.Input(key='pdf_file'), sg.FileBrowse()],
          [sg.Text('Select Output Folder:'), sg.Input(key='output_folder'), sg.FolderBrowse()],
          [sg.Text('Output Image Resolution (DPI):'), sg.Input(key='resolution', default_text='300')],
          [sg.Button('Convert'), sg.Button('Exit')],
          [sg.Output(size=(60, 15))]]

window = sg.Window('PDF to Image Converter', layout)

while True:
    event, values = window.read()
    if event == sg.WIN_CLOSED or event == 'Exit':
        break
    if event == 'Convert':
        pdf_file = values['pdf_file']
        output_folder = values['output_folder']
        resolution = values['resolution']
        try:
            convert_pdf_to_images(pdf_file, output_folder, resolution)
            sg.popup('Conversion complete!', title='Success')
        except Exception as e:
            sg.popup(f'Error: {str(e)}', title='Error')
    else:
        continue

window.close()

import os
import fitz
import PySimpleGUI as sg

# Define the PySimpleGUI layout
layout = [
    [sg.Text('Select PDF file: '), sg.Input(key='-FILE-', enable_events=True, visible=False), sg.FileBrowse()],
    [sg.Text('Select output folder: '), sg.Input(key='-FOLDER-', enable_events=True, visible=False), sg.FolderBrowse()],
    [sg.Text('Resolution (dpi): '), sg.Input(key='-RESOLUTION-', default_text='300')],
    [sg.Multiline(key='-LOG-', size=(80, 20), autoscroll=True)],
    [sg.Button('Extract Images'), sg.Button('Exit')]
]

# Create the PySimpleGUI window
window = sg.Window('PDF Image Extractor', layout)

# Event loop
while True:
    event, values = window.read()
    if event == sg.WIN_CLOSED or event == 'Exit':
        break
    if event == 'Extract Images':
        filename = values['-FILE-']
        output_folder = values['-FOLDER-']
        resolution = int(values['-RESOLUTION-'])

        if not filename:
            sg.popup('Please select a PDF file')
            continue
        if not output_folder:
            sg.popup('Please select an output folder')
            continue

        # Open the PDF file
        pdf = fitz.open(filename)

        # Iterate over each page
        for page in range(pdf.page_count):
            # Get the current page
            current_page = pdf[page]

            # Get the bounding box for the page and apply the rotation
            bbox = current_page.rect
            if current_page.rotation:
                bbox = bbox.rect
                bbox.pre_rotate(-current_page.rotation)

            # Render the page as an image
            pixmap = page.get_pixmap(matrix=fitz.Matrix(300/72, 300/72))
            # Resize the pixmap to desired dimensions
            pixmap = pixmap.scaledToWidth(1200, mode=Qt.SmoothTransformation)

            # Save the image to the output folder
            output_file = os.path.join(output_folder, f'page_{page+1}.png')
            pix.save(output_file)

            # Write to the log
            log_text = f'Saved {output_file}\n'
            window['-LOG-'].print(log_text, end='')

        # Close the PDF file
        pdf.close()

# Close the PySimpleGUI window
window.close()

from PIL import Image, ImageEnhance

#read the image
im = Image.open("ext_im.jpg")

#image brightness enhancer
enhancer = ImageEnhance.Brightness(im)

factor = 1 #gives original image
im_output = enhancer.enhance(factor)
im_output.save('ext_im-1.jpg')

factor = 1.5## brightens the image
im_output = enhancer.enhance(factor)
im_output.save('ext_im-2.jpg')


import cv2
import numpy as np

# Load the image
img = cv2.imread('image.jpg')

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply binary thresholding to the image
ret, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

# Apply morphological operations to remove noise and smooth the image
kernel = np.ones((3,3), np.uint8)
closing = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=2)

# Find the contours in the image
contours, hierarchy = cv2.findContours(closing, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Iterate through the contours to find the largest rectangle
largest_area = 0
largest_rect = None
for contour in contours:
    area = cv2.contourArea(contour)
    if area > largest_area:
        perimeter = cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, 0.02 * perimeter, True)
        if len(approx) == 4:
            largest_area = area
            largest_rect = approx

# Draw the largest rectangle on the image
cv2.drawContours(img, [largest_rect], 0, (0, 255, 0), 2)

# Display the image with the largest rectangle drawn on it
cv2.imshow('Image', img)
cv2.waitKey(0)
cv2.destroyAllWindows()


import cv2
import numpy as np

# Load the image
img = cv2.imread('image.jpg')

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply adaptive thresholding to the image
thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 11, 2)

# Apply bilateral filtering to smooth the image while preserving edges
smooth = cv2.bilateralFilter(thresh, 5, 75, 75)

# Apply morphological operations to further remove noise and fill in gaps
kernel = np.ones((3,3), np.uint8)
closing = cv2.morphologyEx(smooth, cv2.MORPH_CLOSE, kernel, iterations=2)

# Save the enhanced image
cv2.imwrite('enhanced_image.jpg', closing)

import cv2

# Load the image
img = cv2.imread('image.jpg')

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Perform unsharp masking to sharpen the image
blur = cv2.GaussianBlur(gray, (0, 0), 3)
sharpened = cv2.addWeighted(gray, 1.5, blur, -0.5, 0)

# Save the sharpened image
cv2.imwrite('sharpened_image.jpg', sharpened)



import openpyxl

# Open the two Excel files
wb1 = openpyxl.load_workbook('file1.xlsx')
wb2 = openpyxl.load_workbook('file2.xlsx')

# Get the sheets to compare
sheet1 = wb1['Sheet1']
sheet2 = wb2['Sheet1']

# Define the unique ID column
id_col = 'A'

# Define the text value column to compare
text_col = 'B'

# Create a dictionary to store the values of the first file
values1 = {}
for row in sheet1.iter_rows(min_row=2, values_only=True):
    id_value = row[0]
    text_value = row[1]
    values1[id_value] = text_value

# Create a dictionary to store the values of the second file
values2 = {}
for row in sheet2.iter_rows(min_row=2, values_only=True):
    id_value = row[0]
    text_value = row[1]
    values2[id_value] = text_value

# Compare the values and create a new column with the differences
sheet1['C1'] = 'Difference'
for row in sheet1.iter_rows(min_row=2):
    id_value = row[0].value
    if id_value in values2:
        if row[1].value != values2[id_value]:
            row[2].value = f'{row[1].value} != {values2[id_value]}'
    else:
        row[2].value = 'ID not found in second file'

# Save the updated file
wb1.save('file1_updated.xlsx')

import openpyxl

# Open the two Excel files
wb1 = openpyxl.load_workbook('file1.xlsx')
wb2 = openpyxl.load_workbook('file2.xlsx')

# Get the sheets to compare
sheet1 = wb1['Sheet1']
sheet2 = wb2['Sheet1']

# Define the unique ID column
id_col = 'A'

# Get the column headers
headers = [cell.value for cell in sheet1[1]]

# Create a dictionary to store the values of the first file
values1 = {}
for row in sheet1.iter_rows(min_row=2, values_only=True):
    id_value = row[0]
    values1[id_value] = row[1:]

# Create a dictionary to store the values of the second file
values2 = {}
for row in sheet2.iter_rows(min_row=2, values_only=True):
    id_value = row[0]
    values2[id_value] = row[1:]

# Compare the values and create new columns with the differences
for col_idx, header in enumerate(headers[1:], start=2):
    sheet1.cell(row=1, column=col_idx+len(headers)).value = f'{header} Difference'
    for row in sheet1.iter_rows(min_row=2):
        id_value = row[0].value
        if id_value in values2:
            if row[col_idx-1].value != values2[id_value][col_idx-2]:
                row[col_idx+len(headers)-1].value = f'{row[col_idx-1].value} != {values2[id_value][col_idx-2]}'
        else:
            row[col_idx+len(headers)-1].value = 'ID not found in second file'

# Save the updated file
wb1.save('file1_updated.xlsx')

 Sure, here's a possible approach that the team took to achieve the project accomplishment:

Define the project goal and scope: The team first defined the goal of the project, which was to update missing email addresses of contacts for businesses. They also determined the scope of the project, including the number of records to remediate and the target audience to email.

Plan and prioritize tasks: The team then planned and prioritized the tasks necessary to achieve the project goal. This included identifying the internal tools and techniques needed to email assistants and build internal tools, determining the best way to contact bankers' assistants, and deciding on a follow-up process.

Develop and implement internal tools: The team developed and implemented internal tools, such as Excel VBA and Python, to email assistants and retrieve missing email addresses. This required technical skills and collaboration to ensure the tools were effective and efficient.

Contact bankers' assistants: The team emailed approximately 1300 bankers' assistants to request missing email addresses. They provided clear and concise instructions on how to provide the missing information, and also educated them on the importance of the project.

Follow up with assistants: The team ensured proper follow-up was done to get responses from bankers' assistants. They also answered queries and provided assistance to assistants who needed help with the email remediation process.

Remediate email addresses: The team successfully remediated email addresses for 44k records and proposed email remediation for 21k records. They ensured the accuracy of the email addresses and updated them in the appropriate systems.

Evaluate and report: The team evaluated the project to determine its success and identified areas for improvement. They also reported the results of the project to stakeholders and shared insights gained during the process.

Overall, the team used a strategic and collaborative approach to achieve the project goal of updating missing email addresses for businesses. They leveraged their technical skills and interpersonal communication to achieve the desired outcome.
