import pandas as pd

# Sample data
data = {
    'Accountname': ['Account1', 'Account2', 'Account1', 'Account2', 'Account1'],
    'Year': [2021, 2022, 2022, 2023, 2023],
    'Month': ['Dec', 'Jan', 'Feb', 'Jan', 'Feb'],
    'Duration': [20, 10, 15, 12, 8]
}

df = pd.DataFrame(data)

# Create a random date column based on 'Year' and 'Month'
df['Date'] = pd.to_datetime(df['Year'].astype(str) + df['Month'], format='%Y%b')

# Create a range of months from the minimum to the maximum month
month_range = pd.date_range(df['Date'].min(), df['Date'].max(), freq='M').strftime('%b')

# Create a DataFrame with all possible combinations of Accountname and Month
combinations = pd.MultiIndex.from_product([df['Accountname'].unique(), month_range], names=['Accountname', 'Month'])
all_data = pd.DataFrame(index=combinations).reset_index()

# Merge the original data with all possible combinations, filling missing values with zero duration
merged_df = pd.merge(all_data, df, on=['Accountname', 'Month'], how='left').fillna({'Duration': 0})

# Sort the DataFrame by Accountname and Date
merged_df = merged_df.sort_values(['Accountname', 'Date'])

# Calculate the rolling average for each account over the last 6 months, considering zero duration for missing months
merged_df['RollingAverage'] = merged_df.groupby('Accountname')['Duration'].transform(lambda x: x.rolling(6, min_periods=1).mean()).fillna(0)

# Filter data for 2022 and 2023
filtered_df = merged_df[merged_df['Year'].isin([2022, 2023])]

# Pivot the DataFrame to have months as columns and arrange them in order
month_order = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
filtered_df['Month'] = pd.Categorical(filtered_df['Month'], categories=month_order, ordered=True)
result = filtered_df.pivot_table(index=['Accountname', 'Year'], columns='Month', values='RollingAverage')

print(result)
